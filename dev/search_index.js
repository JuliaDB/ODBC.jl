var documenterSearchIndex = {"docs":
[{"location":"#ODBC.jl-1","page":"Home","title":"ODBC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The ODBC.jl package provides high-level julia functionality over the low-level ODBC API. In particular, the package allows making connections with any database that has a valid ODBC driver, sending SQL queries to those databases, and streaming the results into a variety of data sinks.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depth = 3","category":"page"},{"location":"#ODBC-administrative-functions-1","page":"Home","title":"ODBC administrative functions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ODBC.drivers\nODBC.dsns\nODBC.adddriver\nODBC.removedriver\nODBC.adddsn\nODBC.removedsn\nODBC.setdebug","category":"page"},{"location":"#ODBC.drivers","page":"Home","title":"ODBC.drivers","text":"ODBC.drivers() -> Dict\n\nList installed ODBC drivers. The primary config location for installed drivers on non-windows platforms is realpath(joinpath(dirname(pathof(ODBC)), \"../config/odbcinst.ini\")), i.e. an ODBC.jl-managed location. Other system/user locations may also be checked (and are used by default on windows) by the underlying ODBC driver manager, but for the most consistent results, aim to allow ODBC.jl to manage installed drivers/datasources via ODBC.addriver, ODBC.removedriver, etc.\n\nOn windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via ODBC.adddriver/ODBC.removdriver and ODBC.adddsn/ODBC.removedsn, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing \"Run as administrator\".\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.dsns","page":"Home","title":"ODBC.dsns","text":"ODBC.dsns() -> Dict\n\nList installed ODBC datasources. The primary config location for installed datasources on non-windows platforms is realpath(joinpath(dirname(pathof(ODBC)), \"../config/odbc.ini\")), i.e. an ODBC.jl-managed location. Other system/user locations may also be checked (and are by default on windows) by the underlying ODBC driver manager, but for the most consistent results, aim to allow ODBC.jl to manage installed drivers/datasources via ODBC.adddsn, ODBC.removedsn, etc.\n\nOn windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via ODBC.adddriver/ODBC.removdriver and ODBC.adddsn/ODBC.removedsn, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing \"Run as administrator\".\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.adddriver","page":"Home","title":"ODBC.adddriver","text":"ODBC.adddriver(name, libpath; kw...)\n\nInstall a new ODBC driver. name is a user-provided \"friendly\" name to identify the driver. libpath is the absolute path to the ODBC driver shared library. Other key-value driver properties can be provided by the kw... keyword arguments.\n\nThis method is provided to try and provide the simplest/easiest/most consistent setup experience for installing a new driver. Editing configuration files by hand is error-prone and it's easy to miss adding something that is required.\n\nWhile ODBC.jl supports all 3 major ODBC driver managers (unixODBC, iODBC, and odbc32), be aware that most DBMS ODBC driver libraries are built against only one of the 3 and can lead to compatibility issues if a different driver manager is used. This is mainly an issue for driver libraries built against iODBC and then tried to use with unixODBC or vice-versa.\n\nOn windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via ODBC.adddriver/ODBC.removdriver and ODBC.adddsn/ODBC.removedsn, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing \"Run as administrator\".\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.removedriver","page":"Home","title":"ODBC.removedriver","text":"ODBC.removedriver(name; removedsns::Bool=true)\n\nRemove an installed ODBC driver by name (as returned from ODBC.drivers()). removedsns=true also removes any datasources that were specified to use the driver.\n\nOn windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via ODBC.adddriver/ODBC.removdriver and ODBC.adddsn/ODBC.removedsn, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing \"Run as administrator\".\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.adddsn","page":"Home","title":"ODBC.adddsn","text":"ODBC.adddsn(name, driver; kw...)\n\nInstall a new ODBC datasource. name is a user-provided \"friendly\" name to identify the datasource (dsn). driver is the \"friendly\" driver name that should be used to connect to the datasource (valid driver options can be seen from ODBC.drivers()). Additional connection key-value properties can be provided by the kw... keyword arguments.\n\nDatasources can be connected by calling DBInterface.connect(ODBC.Connection, dsn, user, pwd), where dsn is the friendly datasource name, user is the username, and pwd is the password.\n\nAn alternative approach to installing datasources is to generate a valid \"connection string\" that includes all connection properties in a single string passed to DBInterface.connect. www.connectionstrings.com is a convenient resource that provides connection string templates for various database systems.\n\nOn windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via ODBC.adddriver/ODBC.removdriver and ODBC.adddsn/ODBC.removedsn, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing \"Run as administrator\".\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.removedsn","page":"Home","title":"ODBC.removedsn","text":"ODBC.removedsn(name)\n\nRemove an installed datasource by name (as returned from ODBC.dsns()).\n\nOn windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via ODBC.adddriver/ODBC.removdriver and ODBC.adddsn/ODBC.removedsn, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing \"Run as administrator\".\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.setdebug","page":"Home","title":"ODBC.setdebug","text":"ODBC.setdebug(debug::Bool=true, tracefile::String=joinpath(tempdir(), \"odbc.log\"))\n\nTurn on ODBC library call tracing. This prints debug information to tracefile upon every entry and exit from calls to the underlying ODBC library (unixODBC, iODBC, or odbc32). Debugging can be turned off by passing false.\n\nNote that setting tracing on/off requires resetting the ODBC environment, which means any open statements/connections will be closed/invalid.\n\nAlso note that due to the persistent nature of ODBC config, setting tracing will persist acrosss Julia sessions, i.e. if you turn tracing on, then quit julia and start again tracing will still be on, and will stay on until explicitly turned off.\n\nThe iODBC driver manager supports passing stderr as the tracefile, which will print all tracing information into the julia session/repl.\n\n\n\n\n\n","category":"function"},{"location":"#DBMS-Connections-1","page":"Home","title":"DBMS Connections","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DBInterface.connect\nODBC.Connection\nDBInterface.close!","category":"page"},{"location":"#DBInterface.connect","page":"Home","title":"DBInterface.connect","text":"DBInterface.connect(ODBC.Connection, dsn_or_connectionstring, user, password; connectionstring::Bool=false)\n\nConstruct a Connection type by connecting to a valid ODBC Connection or by specifying a datasource name or valid connection string. Takes optional 2nd and 3rd arguments for named datasources username and password, respectively. 1st argument dsn can be either the name of a pre-defined ODBC Connection or a valid connection string. If passing a connection string, the connectionstring=true keyword argument must also be passed. The user and pwd arguments are ignored if connectionstring=true. A great resource for building valid connection strings is http://www.connectionstrings.com/.\n\n\n\n\n\n","category":"function"},{"location":"#ODBC.Connection","page":"Home","title":"ODBC.Connection","text":"ODBC.Connection(dsn_or_connectionstring, user, password; connectionstring::Bool=false)\n\nConstruct a Connection type by connecting to a valid ODBC Connection or by specifying a datasource name or valid connection string. Takes optional 2nd and 3rd arguments for named datasources username and password, respectively. 1st argument dsn can be either the name of a pre-defined ODBC Connection or a valid connection string. If passing a connection string, the connectionstring=true keyword argument must also be passed. The user and pwd arguments are ignored if connectionstring=true. A great resource for building valid connection strings is http://www.connectionstrings.com/.\n\n\n\n\n\n","category":"type"},{"location":"#DBInterface.close!","page":"Home","title":"DBInterface.close!","text":"DBInterface.close!(conn)\n\nClose an open connection. In general, statements and open cursors will not be valid once a connection has been closed.\n\n\n\n\n\nDBInterface.close!(stmt)\n\nClose a prepared statement. Further parameter binding or execution will not be valid.\n\n\n\n\n\n","category":"function"},{"location":"#Query-execution-and-result-handling-1","page":"Home","title":"Query execution and result handling","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DBInterface.prepare\nDBInterface.execute\nDBInterface.executemultiple","category":"page"},{"location":"#DBInterface.prepare","page":"Home","title":"DBInterface.prepare","text":"DBInterface.prepare(conn, sql) -> ODBC.Statement\n\nPrepare a query string, optionally including parameters to bind upon execution (with ? markers). Please refer to individual dbms documentation for the exact level of parameter binding support.\n\nThe returned prepared statement can then be passed to DBInterface.execute(stmt, params) with params that will be bound before execution. This allows preparing the statement once, and re-using it many times with different parameters (or the same) efficiently.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.execute","page":"Home","title":"DBInterface.execute","text":"DBInterface.execute(stmt, params=(); iterate_rows::Bool=false, ignore_driver_row_count::Bool=false, normalizenames::Bool=false, debug::Bool=false) -> ODBC.Cursor\n\nExecute a prepare statement, binding any parameters beforehand. Returns a Cursor object, even if the statement is not resultset-producing (cursor will have zero rows and/or columns). The Cursor object satisfies the Tables.jl interface as a source, so any valid sink can be used for inspecting results (a list of integrations is maintained here).\n\nSupported keyword arguments include:\n\niterate_rows::Bool: for forcing row iteration of the resultset\nignore_driver_row_count::Bool: for ignoring the row count returned from the database driver; in some cases (Netezza), the driver may return an incorrect or \"prefetched\" number for the row count instead of the actual row count; this allows ignoring those numbers and fetching the resultset until truly exhausted\nnormalizenames::Bool: normalize column names to valid Julia identifiers; this can be convenient when working with the results in, for example, a DataFrame where you can access columns like df.col1\ndebug::Bool: for printing additional debug information during the query/result process.\n\n\n\n\n\nDBInterface.execute(conn, sql, params=(); iterate_rows::Bool=false, ignore_driver_row_count::Bool=false, normalizenames::Bool=false, debug::Bool=false) -> ODBC.Cursor\n\nSend a query directly to connection for execution. Returns a Cursor object, even if the statement is not resultset-producing (cursor will have zero rows and/or columns). The Cursor object satisfies the Tables.jl interface as a source, so any valid sink can be used for inspecting results (a list of integrations is maintained here).\n\nSupported keyword arguments include:\n\niterate_rows::Bool: for forcing row iteration of the resultset\nignore_driver_row_count::Bool: for ignoring the row count returned from the database driver; in some cases (Netezza), the driver may return an incorrect or \"prefetched\" number for the row count instead of the actual row count; this allows ignoring those numbers and fetching the resultset until truly exhausted\nnormalizenames::Bool: normalize column names to valid Julia identifiers; this can be convenient when working with the results in, for example, a DataFrame where you can access columns like df.col1\ndebug::Bool: for printing additional debug information during the query/result process.\n\nThis is an alternative execution path to DBInterface.execute with a prepared statement. This method is faster/less overhead for one-time executions, but prepared statements will have more benefit for repeated executions (even with different parameters).\n\n\n\n\n\n","category":"function"}]
}
